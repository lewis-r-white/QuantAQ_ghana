---
title: "Gas Data Prep"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

options(scipen=999)
```

This R Markdown document reads in processed SD card, merges it with cloud data, and applies correction formula based on co-location regression.
 
It starts by cleaning particulate matter (PM) data, and then follows with gas data. 

```{r packages, echo=FALSE, message=FALSE, warning=FALSE}
### load packages 

library(here) # file path org
library(lubridate)# working with dates
library(tictoc) # timing
library(DT) # datatables
library(purrr) # applying functions across df
library(tidyverse) # data cleaning and plotting
library(data.table) 
library(sf) # spatial data 
library(viridis) # color pallete 
library(knitr)
library(modelsummary) # table of regressions
library(spdep)
library(gstat)
library(units) 
library(gridExtra)
library(broom)
library(Metrics) 
library(kableExtra) # table creation
library(GGally)
library(yaml)

# source in function that loads each pollution dataset separately to keep data small and prevent R crashes 
source(here("src", "load_pollution_datasets.R"))

# source function that merges cloud/sd card data for for multiple pollutants at once 
source(here("src", "merge_cloud_sd_colocation_and_community.R"))

# source function to apply regressions when comparing monitor to fleet average
source(here("src", "compare_fleet_regression.R")) # INCLUDES apply_regression and run_regression_stats functions. 

# source function that aggregates data by time scale of interest (hourly, daily)
source(here("src", "summarize_pollution_times.R"))
```




# Gases

```{r}
### --- Load config ---
config <- read_yaml(here("data_load_and_prep", "calibration.yml"))
gas_cfg <- config$gas_calibration

gases          <- gas_cfg$gases
gas_ref        <- gas_cfg$reference_monitor
gas_start      <- gas_cfg$window_start
gas_end        <- gas_cfg$window_end
gas_thresholds <- gas_cfg$thresholds

```


### load in the data

```{r}
# LOAD SD CARD DATA ----

MOD_sd_card <- read_rds(here("data", "all_measurements", "sd", "full_sd_card_2023-04-24_to_2024-09-11.rds"))

# MOD data loaded above, so just select gases
MOD_gas_sd_card <- MOD_sd_card %>% select(-(pm1:pm25)) %>% mutate(source = "sd_card")

# save output
# write_rds(MOD_gas_sd_card, here("data", "gas", "raw", "gas_sd_card_20230423-20240905.rds"))

# read in gas sd card data if no new SD card data 
MOD_gas_sd_card <- read_rds(here("data", "gas","raw", "gas_sd_card_20230423-20240905.rds"))


# LOAD CLOUD DATA ----

pollutants <- c("co", "no", "no2", "o3")

cloud_file_path <- "/Users/lewiswhite/CHAP_columbia/QuantAQ_ghana/data/all_measurements/cloud/ghana_AQ_parent_full_20230815-20240925.csv"

raw_data <- lapply(pollutants, function(pollutant) {
  full_data <- load_pollution_datasets(pollutant, file_path = cloud_file_path, file_type = "csv")

  # Filter out MOD-PM (keep only MOD devices with gases)
  full_data <- lapply(full_data, function(df) {
    df %>% filter(str_detect(monitor, "^MOD-[^P]"))
  })

  return(full_data)
})

names(raw_data) <- pollutants

```


### Merge the cloud and SD data

```{r}
# If SD card data is missing or zero rows ‚Üí create an empty-but-valid SD tibble
if (nrow(MOD_gas_sd_card) == 0 || is.null(MOD_gas_sd_card)) {
  message("‚ö† No SD card gas data found ‚Äî proceeding with cloud-only workflow")

  MOD_gas_sd_card <- tibble(
    timestamp_iso = as.POSIXct(character()),
    monitor       = character(),
    co            = double(),
    no            = double(),
    no2           = double(),
    o3            = double(),
    source        = character()
  )
}

# ---------------- source in functions to merge data ----------------
source(here("src", "merge_sd_data_gas.R"))
--------------------------------------------------------------------------------
  
  
# merge cloud and SD 
gas_merged_results <- merge_cloud_sd_gas(pollutants, raw_data, MOD_gas_sd_card)


# Extract & deduplicate merged_full
co_merged <- gas_merged_results$co %>% distinct(monitor, timestamp, .keep_all = TRUE)
no_merged <- gas_merged_results$no %>% distinct(monitor, timestamp, .keep_all = TRUE)
no2_merged <- gas_merged_results$no2 %>% distinct(monitor, timestamp, .keep_all = TRUE)
o3_merged <- gas_merged_results$o3 %>% distinct(monitor, timestamp, .keep_all = TRUE)

# Combine into one table
gas_full <- full_join(co_merged, no_merged) %>%
  full_join(no2_merged) %>%
  full_join(o3_merged) %>%
  select(monitor, timestamp, date, hour, co, no, no2, o3, source) %>%
  mutate(source = ifelse(rowSums(across(c(co, no, no2, o3), ~ !is.na(.))) == 0, NA, source))

colocation_gas <- gas_full %>% filter(date <= as.Date("2023-10-25")) 

#write_csv(colocation_gas, here("data", "gas", "colocation", "colocation_gas_20230815-20231025.csv"))

```


### Optional Diagnostics for Calibration (Can Skip)
### Plot gas time series and examine correlations to determine "golden monitor" to be used for colocation correction

This section explores the raw gas data during the colocation period to help identify which Modulair gas monitor behaves most consistently (‚Äúgolden monitor‚Äù). It includes:
  - Daily gas time series by monitor
  - Pairwise correlations across monitors for CO, NO, NO‚ÇÇ, and O‚ÇÉ
  - Scatterplots with regression slopes
  - Visual identification of outliers and drift

These plots are diagnostic only. They are useful for confirming:
   - which monitor is stable enough to use as the colocation reference, and
   - whether any gas channel or monitor should be excluded.

You can skip this entire section if the golden monitor has already been chosen, or if you only need the final calibrated gas dataset.

```{r}
## COLOCATION DATA TIME SERIES ----

colocation_gas <- gas_full %>% 
  filter(date < as.Date("2023-10-26")) 

# write_rds(colocation_gas, here("data", "gas", "colocation", "colocation_gas.rds"))


colocation_gas %>% 
  filter(date < as.Date("2023-10-26")) %>%
  group_by(monitor, date) %>%
  summarise(
    mean_co = mean(co, na.rm = TRUE),
    mean_no2 = mean(no2, na.rm = TRUE),
    mean_o3 = mean(o3, na.rm = TRUE),
    mean_no = mean(no, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  pivot_longer(cols = starts_with("mean_"), names_to = "gas", values_to = "mean_concentration") %>%
  mutate(gas = gsub("mean_", "", gas)) %>%
  ggplot(aes(x = date, y = mean_concentration, color = gas)) +
  geom_line() +
  facet_grid(gas ~ monitor, scales = "free_y") +  # Facet by gas and then monitor
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(y = "Mean Concentration", x = "Date", color = "Gas", title = "Daily Average Time Series for Each Gas/Monitor")



## COMMUNITY DATA TIME SERIES ----

gas_full %>% filter(date > as.Date("2023-10-26")) %>%
  group_by(monitor, date) %>%
  summarise(
    mean_co = mean(co, na.rm = TRUE),
    mean_no2 = mean(no2, na.rm = TRUE),
    mean_o3 = mean(o3, na.rm = TRUE),
    mean_no = mean(no, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  pivot_longer(cols = starts_with("mean_"), names_to = "gas", values_to = "mean_concentration") %>%
  mutate(gas = gsub("mean_", "", gas)) %>%
  ggplot(aes(x = date, y = mean_concentration, color = gas)) +
  geom_line() +
  facet_grid(gas ~ monitor, scales = "free_y") +  # Facet by gas and then monitor
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(y = "Mean Concentration", x = "Date", color = "Gas")
  


### LOOKING AT CORRELATIONS BETWEEN MONITORS -----

# NO SUMMARIZED 
summarized_no <- summarize_pollution_times(colocation_gas, "no")
no_hourly <- summarized_no$hourly

# NO NON FILTER 
# Transform data: Spread 'no' values into wide format by monitor
no_colocation_wide <- no_hourly %>%
  spread(key = monitor, value = mean_no)

# Generate pairwise correlation plot
ggpairs(no_colocation_wide %>% select(`MOD-00397`:`MOD-00401`), 
        upper = list(continuous = wrap("cor", method = "pearson")), 
        lower = list(continuous = wrap("smooth", method = "lm", se = TRUE, color = "blue", alpha = 0.5)),
        diag = list(continuous = "densityDiag")) +  
  theme_minimal() + 
  labs(title = "Pairwise Correlation of Hourly NO Values with Regression Slopes")



# NO WITH FILTER 
no_hourly_filtered <- no_hourly %>% filter(date > as.Date("2023-08-22"))

# Transform data: Spread 'no' values into wide format by monitor
no_colocation_wide <- no_hourly_filtered %>%
  spread(key = monitor, value = mean_no)

ggpairs(no_colocation_wide %>% select(`MOD-00397`:`MOD-00401`), 
        upper = list(continuous = wrap("cor", method = "pearson")), 
        lower = list(continuous = wrap("smooth", method = "lm", se = TRUE, color = "blue", alpha = 0.5)),
        diag = list(continuous = "densityDiag")) +  
  theme_minimal() + 
  labs(title = "Pairwise Correlation of Hourly NO Values", 
       subtitle = "Filtered to after Aug 21 to remove outliers") 
  



# NO2 SUMMARIZED 
summarized_no2 <- summarize_pollution_times(colocation_gas, "no2")
no2_hourly <- summarized_no2$hourly

# NO2 PLOT
# Transform data: Spread 'no2' values into wide format by monitor
no2_colocation_wide <- no2_hourly %>%
  spread(key = monitor, value = mean_no2)

# Generate pairwise correlation plot
ggpairs(no2_colocation_wide %>% select(`MOD-00397`:`MOD-00400`), 
        upper = list(continuous = wrap("cor", method = "pearson")), # Show correlation
        lower = list(continuous = wrap("smooth", method = "lm", se = TRUE, color = "blue", alpha = 0.5)),
        diag = list(continuous = "densityDiag")) +  
  theme_minimal() + 
  labs(title = "Pairwise Correlation of Hourly NO2 Values")




# CO SUMMARIZED 
summarized_co <- summarize_pollution_times(colocation_gas, "co")
co_hourly <- summarized_co$hourly

# CO PLOT
# Transform data: Spread 'co' values into wide format by monitor
co_colocation_wide <- co_hourly %>%
  spread(key = monitor, value = mean_co)

# Generate pairwise correlation plot
ggpairs(co_colocation_wide %>% select(`MOD-00397`:`MOD-00401`), 
        upper = list(continuous = wrap("cor", method = "pearson")), # Show correlation
        lower = list(continuous = wrap("smooth", method = "lm", se = TRUE, color = "blue", alpha = 0.5)),
        diag = list(continuous = "densityDiag")) +  
  theme_minimal() + 
  labs(title = "Pairwise Correlation of Hourly CO Values")



# O3 SUMMARIZED 
summarized_o3 <- summarize_pollution_times(colocation_gas, "o3")
o3_hourly <- summarized_o3$hourly

# O3 PLOT
# Transform data: Spread 'o3' values into wide format by monitor
o3_colocation_wide <- o3_hourly %>%
  spread(key = monitor, value = mean_o3)

# Generate pairwise correlation plot
ggpairs(o3_colocation_wide %>% select(`MOD-00397`:`MOD-00401`), 
        upper = list(continuous = wrap("cor", method = "pearson")), # Show correlation
        lower = list(continuous = wrap("smooth", method = "lm", se = TRUE, color = "blue", alpha = 0.5)),
        diag = list(continuous = "densityDiag")) +  
  theme_minimal() + 
  labs(title = "Pairwise Correlation of Hourly O3 Values")



### REGRESSION WITH SLOPE PLOTS ----
library(ggpubr)

# Select only monitor columns
monitor_cols <- o3_colocation_wide %>% select(`MOD-00397`:`MOD-00401`)

# Get all unique pairs of monitor columns (including self-pairs for a full 5x5 grid)
monitor_pairs <- expand.grid(monitor_x = names(monitor_cols), monitor_y = names(monitor_cols), 
                             stringsAsFactors = FALSE)

# Function to generate scatterplot with regression line and annotation
plot_regression <- function(x, y) {
  df <- no_colocation_wide %>% select(all_of(c(x, y))) %>% drop_na()
  
  # Compute correlation and regression slope
  cor_val <- round(cor(df[[x]], df[[y]], use = "complete.obs"), 3)
  model <- lm(df[[y]] ~ df[[x]], data = df)
  slope_val <- round(coef(model)[2], 3)
  
  ggplot(df, aes(x = .data[[x]], y = .data[[y]])) +
    geom_point(alpha = 0.5) +
    geom_smooth(method = "lm", color = "blue") +
    labs(title = paste(x, "vs", y),
         subtitle = paste("Corr:", cor_val, "\nSlope:", slope_val),
         x = x, y = y) +
    theme_minimal()
}

# Generate a list of plots for each pair of monitors
plot_list <- map2(monitor_pairs$monitor_x, monitor_pairs$monitor_y, plot_regression)

# Arrange the plots into a grid using ggarrange
ggarrange(plotlist = plot_list, ncol = 5, nrow = 5)
```



### Determine colocation correction equations and build calibration tables

**Run this section only if you want to update or recompute calibration equations** (e.g., new colocations, revised thresholds, new monitors).

If no new calibration is needed, skip this entire section ‚Äî the next step (‚ÄúApply correction equations‚Ä¶‚Äù) will automatically load your most recent saved calibration tables from the data/calibration folder. 

If a new calibration is needed, adjust the dates to align with the new colocation window and re-run. 

This section produces a calibration table per gas with one row per monitor that passed quality checks.
- We later use this table to correct all minutely data with: corrected = (raw - intercept) / slope

With gases, we set up the regressions to compare each monitor's measurement to "golden monitor" selected from the diagnostic plots/tables in the previous section. We also call this the reference monitor method. 

**Reference-monitor method** (Gas specific) 
-   For each new monitor, regress monitor_raw \~ reference.
-   Any new monitors added to the fleet should be colocated with the "golden monitor" 

**Inputs this section expects**
-   merged_results[[p]] for each gas (o3, no2, no, co) with monitor, timestamp, date, hour, gas, source.
-   config with thresholds and windows (your YAML).

**Warning**
-   The gas readings do not always appear to be stable. Carefully examine the regression plots. 

**Common pitfalls**
  - No rows produced ‚Äî usually means there‚Äôs no temporal overlap between the reference and targets in the window, or thresholds are too strict.
  - Reference has no prior baseline ‚Äî Ensure the reference monitor appears in the calibration table for the pollutant, and that fitted_on (or colocation_end) is parseable.

```{r}
# Purpose: Build gas calibration slopes/intercepts using the colocation period only. Run ONLY when:
#  - a new golden monitor is chosen
#  - the colocation window changes
#  - new monitors are added to the gas fleet

# Output:
#   data/calibration/gas_calibration_table_coefs.csv

source(here("src", "merge_sd_data_gas.R"))
source(here("src", "load_pollution_datasets.R"))

### Pull data from golden monitor 

# This section extracts hourly gas concentrations from the monitor chosen as the ‚Äúgolden monitor‚Äù (here, MOD-00397) during the colocation period.

# We join this reference time series back onto the colocation dataset so each monitor can be regressed against the same reference measurements.

# If the golden monitor choice has already been validated (via correlations or prior work), you can update the monitor ID here directly without re-running the diagnostic plots.

get_reference_data <- function(colocation_data, monitor_id, gases) {
  ref_cols <- paste0("reference_", gases)
  
  colocation_data %>%
    filter(monitor == monitor_id) %>%
    select(timestamp, all_of(gases)) %>%
    rename_with(~ ref_cols, all_of(gases))
}




## Fit Calibration Regressions (Determine the correction equation)

# For each gas and for each monitor in the colocation period, we estimate a simple linear calibration model:
#  - Monitor Gas = ùõº + ùõΩ √ó Reference Gas

# These slopes and intercepts are then used to correct all community-period gas values.
get_gas_regression_results <- function(colocation_with_ref,
                                       gases,
                                       reference_gases,
                                       min_points,
                                       min_r2) {
  results_list <- list()
  
  for (mon in unique(colocation_with_ref$monitor)) {
    monitor_data <- colocation_with_ref %>% filter(monitor == mon)
    
    for (i in seq_along(gases)) {
      gas           <- gases[i]
      reference_gas <- reference_gases[i]
      
      valid_data <- monitor_data %>%
        filter(!is.na(.data[[gas]]),
               !is.na(.data[[reference_gas]]))
      
      if (nrow(valid_data) >= min_points) {
        model <- lm(as.formula(paste(gas, "~", reference_gas)), data = valid_data)
        r2    <- summary(model)$r.squared
        
        if (!is.na(r2) && r2 >= min_r2) {
          results_list[[length(results_list) + 1]] <- tibble(
            monitor   = mon,
            gas       = gas,
            slope     = coef(model)[[2]],
            intercept = coef(model)[[1]],
            R2        = r2
          )
        } else {
          # Not enough linear relationship / poor fit
          results_list[[length(results_list) + 1]] <- tibble(
            monitor   = mon,
            gas       = gas,
            slope     = NA_real_,
            intercept = NA_real_,
            R2        = r2
          )
        }
      } else {
        # Not enough paired points
        results_list[[length(results_list) + 1]] <- tibble(
          monitor   = mon,
          gas       = gas,
          slope     = NA_real_,
          intercept = NA_real_,
          R2        = NA_real_
        )
      }
    }
  }
  
  bind_rows(results_list)
}


# Load colocation gas
colocation_gas <- read_rds(here("data", "gas", "colocation", "colocation_gas_20230815-20231025.rds"))

gases <- c("co", "no", "no2", "o3")

gas_cfg      <- config$gas_calibration
gas_thresh   <- gas_cfg$thresholds
min_points   <- gas_thresh$min_points   # e.g., 500
min_r2       <- gas_thresh$min_r2       # e.g., 0.5


reference_data <- get_reference_data(colocation_gas, "MOD-00397", gases)

colocation_with_ref <- left_join(colocation_gas, reference_data, by = "timestamp")

regression_results <- get_gas_regression_results(
  colocation_with_ref,
  gases,
  paste0("reference_", gases),
  min_points = min_points,
  min_r2     = min_r2
)


write_csv(
  regression_results,
  here("data", "calibration", "gas_calibration_table_coefs.csv")
)
```

## Apply Calibration to Community Data
Here we apply the slope and intercept from the calibration equations to all community-period observations (i.e., after the colocation window).

For each gas: Corrected= (Raw‚àíŒ±)/Œ≤ 

### Apply the correction equation 


```{r}
# load the calibration coefficient table 
regression_results <- read_csv(
  here("data", "calibration", "gas_calibration_table_coefs.csv")
)

## function to apply the correction 
apply_gas_correction <- function(community_gas, regression_table, gases) {
  # Reshape regression table
  reformat <- regression_table %>%
    select(monitor, gas, slope, intercept) %>%
    pivot_longer(c(slope, intercept), names_to = "param", values_to = "value") %>%
    mutate(param = paste(gas, param, sep = "_")) %>%
    select(-gas) %>%
    pivot_wider(names_from = param, values_from = value)
  
  # Join and correct
  community_gas %>%
    left_join(reformat, by = "monitor") %>%
    mutate(
      co  = (co - co_intercept) / co_slope,
      no  = (no - no_intercept) / no_slope,
      no2 = (no2 - no2_intercept) / no2_slope,
      o3  = (o3 - o3_intercept) / o3_slope
    ) %>%
    select(monitor, timestamp, date, hour, co, no, no2, o3, source)
}


# apply gas correction function 

corrected_community_gas <- apply_gas_correction(gas_full %>% filter(date >= as.Date("2023-09-26")), regression_results, gases)

# Save output 
#write_rds(corrected_community_gas, here("data", "gas", "final", "corrected_community_gas_20230926-20240816.rds"))
```


### Summarize the data

```{r}
summarize_corrected_gases <- function(corrected_data, gases) {
  summaries <- list()
  for (gas in gases) {
    gas_df <- corrected_data %>%
      select(monitor, timestamp, date, hour, source, !!sym(gas))
    summaries[[gas]] <- summarize_pollution_times(gas_df, gas)
  }
  return(summaries)
}

summarized_gases <- summarize_corrected_gases(corrected_community_gas, gases)



co_community_hourly <- summarized_gases$co$hourly
no_community_hourly <- summarized_gases$no$hourly
no2_community_hourly <- summarized_gases$no2$hourly
o3_community_hourly <- summarized_gases$o3$hourly

co_community_daily <- summarized_gases$co$daily
no_community_daily <- summarized_gases$no$daily
no2_community_daily <- summarized_gases$no2$daily
o3_community_daily <- summarized_gases$o3$daily
```


### Save the output 

```{r}
# # Save as CSV
# write_csv(co_community_hourly, here("data", "gas", "summarized", "co_community_hourly_20231024-20240816.csv"))
# write_csv(no_community_hourly, here("data", "gas", "summarized", "no_community_hourly_20231024-20240816.csv"))
# write_csv(no2_community_hourly, here("data", "gas", "summarized", "no2_community_hourly_20231024-20240816.csv"))
# write_csv(o3_community_hourly, here("data", "gas", "summarized", "o3_community_hourly_20231024-20240816.csv"))

# write_csv(co_community_daily, here("data", "gas", "summarized", "co_community_daily_20231024-20240816.csv"))
# write_csv(no_community_daily, here("data", "gas", "summarized", "no_community_daily_20231024-20240816.csv"))
# write_csv(no2_community_daily, here("data", "gas", "summarized", "no2_community_daily_20231024-20240816.csv"))
# write_csv(o3_community_daily, here("data", "gas", "summarized", "o3_community_daily_20231024-20240816.csv"))
```


