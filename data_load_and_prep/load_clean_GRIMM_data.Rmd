---
title: "Load and Clean GRIMM Data"
output: html_document
date: "2025-05-22"
editor_options: 
  markdown: 
    wrap: 72
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

options(scipen=999)
```

```{r, echo=FALSE, message=FALSE, warning=FALSE}
library(tidyverse)
library(here)
library(lubridate)
library(bitops)
library(gt)
```

## Description of cleaning

The GRIMM device stores each environmental sensor reading (temperature,
RH, pressure, input3) as a 10-bit ADC value split across two places:

-   Ue1–Ue4 contain the high 8 bits

-   UeL contains the low 2 bits for all four sensors packed together

To reconstruct the full 10-bit value (0–1023):

-   Extract the low 2 bits for each sensor from UeL

-   Shift the high 8 bits left by 2 positions (equivalent to multiplying
    by 4)

-   Add the low bits back in

Once the 10-bit ADC value is reconstructed, convert it to voltage:

-   voltage = ADC × (10 / 1024)

Finally, apply the instrument-specific calibration parameters from the
\$(1..4) and \*(1..4) lines in the file:

1.  **Temp:** factor = 20; offset = 2.000
2.  **RH:** factor = 20; offset = 0
3.   **Pressure:** factor = 176.21145; offset = 0.275

This produces properly calibrated °C, %RH, and hPa values.


## Example Using One GRIMM file

```{r, echo=TRUE}
# path to GRIMM text file
file_path <- "/Users/lewiswhite/CHAP_columbia/QuantAQ_ghana/data/FEMs/GRIMM/raw/GRIMM_20250811_20251008/D250811.TXT"

# read the entire file
lines <- read_lines(file_path)

# identify the P and N_ lines
p_lines <- lines[grepl("^\\s*P", lines)]
n_lines <- lines[grepl("^\\s*N_", lines)]

# clean P and N lines to be reformatted to data frame
p_lines_clean <- str_remove(str_trim(p_lines), "^P\\s+") 
n_lines_clean <- str_remove(str_trim(n_lines), "^N_\\s+")

# parse P lines (datetime and sensor data)
p_data <- read_table(p_lines_clean,
                      col_names = FALSE,
                      col_types = cols(.default = "d"),
                      skip_empty_rows = TRUE)

# add column names for P lines (see your PI's notes)
names(p_data)[1:5] <- c("year", "month", "day", "hour", "minute")

names(p_data)[6:10] <- c("location", "gravimetric_factor", "error_code", "battery_voltage", "valve_current")

names(p_data)[11:16] <- c("UeL",
                          "Ue4",
                          "Ue3",
                          "Ue2",
                          "Ue1",
                          "lv")

head(p_data) %>%
  gt() %>%
  tab_header(
    title = "Renamed Data ~ Uncleaned",
  )

# factors and offsets pulled from device metadata
temp_factor = 20
temp_offset = 2

RH_factor = 20
RH_offset = 0

pressure_factor = 176.21145
pressure_offset = 0.275

p_data_clean <- p_data %>%
  mutate(

    # extract low 2 bits for each sensor from UeL 
    lo1 = bitAnd(UeL, 3L),  # bits 0–1 → sensor 1, 3L pulls last two bits 
    lo2 = bitAnd(bitShiftR(UeL, 2L), 3L), # bits 2–3 → sensor 2, this shift bits 2&3 to the last two, then pulls
    lo3 = bitAnd(bitShiftR(UeL, 4L), 3L), # bits 4–5 → sensor 3, this shift bits 4&5 to the last two, then pulls
    lo4 = bitAnd(bitShiftR(UeL, 6L), 3L), # bits 6–7 → sensor 4, this shift bits 6&7 to the last two, then pulls

    # reconstruct full 10-bit ADC values (high_bits * 4 + low_bits)
    adc1 = Ue1 * 4L + lo1,   # temperature channel
    adc2 = Ue2 * 4L + lo2,   # humidity channel
    adc3 = Ue3 * 4L + lo3,   # input3 (not used)
    adc4 = Ue4 * 4L + lo4,   # pressure channel

    #  convert ADC → voltage (10 V range, 10-bit resolution) 
    volt1 = adc1 * 10 / 1024,
    volt2 = adc2 * 10 / 1024,
    volt4 = adc4 * 10 / 1024,

    # apply GRIMM calibration (factor + offset) 
    temp_c       = (volt1 - temp_offset) * temp_factor, 
    rh_percent   = (volt2 - RH_offset) * RH_factor,
    pressure_hpa = (volt4 - pressure_offset) * pressure_factor
  )


# parse N_ lines (PM data)
n_data <- read_table(n_lines_clean,
                      col_names = c("pm10", "pm25"),
                      skip_empty_rows = TRUE)



# Identify which lines were P and N in original file
line_types <- tibble(
  line = lines,
  type = case_when(
    grepl("^\\s*P", line)  ~ "P",
    grepl("^\\s*N_", line) ~ "N",
    TRUE                   ~ "OTHER"
  )
)

# Extract row indices for P and N
p_idx <- which(line_types$type == "P")
n_idx <- which(line_types$type == "N")

# Keep only P rows that have a following N row
valid_p_idx <- p_idx[seq_along(n_idx)]

# Trim p_data_clean so it matches N rows exactly
p_data_clean_matched <- p_data_clean %>%
    dplyr::slice(seq_len(length(n_idx)))

# Now safely combine
combined <- bind_cols(p_data_clean_matched, n_data) %>%
  mutate(datetime = make_datetime(year + 2000, month, day, hour, minute)) %>%
  select(datetime, everything())
```


## Create function to loop through

```{r}
load_grimm_file <- function(file_path) {
  
  # --- read entire file ---
  lines <- read_lines(file_path)

  # --- extract P and N lines ---
  p_lines <- lines[grepl("^\\s*P", lines)]
  n_lines <- lines[grepl("^\\s*N_", lines)]

  p_lines_clean <- str_remove(str_trim(p_lines), "^P\\s+") 
  n_lines_clean <- str_remove(str_trim(n_lines), "^N_\\s+")

  # --- parse P lines ---
  p_data <- read_table(p_lines_clean,
                       col_names = FALSE,
                       col_types = cols(.default = "d"),
                       skip_empty_rows = TRUE)

  # --- name columns ---
  names(p_data)[1:5]  <- c("year", "month", "day", "hour", "minute")
  names(p_data)[6:10] <- c("location", "gravimetric_factor", "error_code", 
                           "battery_voltage", "valve_current")
  names(p_data)[11:16] <- c("UeL","Ue4","Ue3","Ue2","Ue1","lv")

  # --- parse N lines ---
  n_data <- read_table(n_lines_clean,
                       col_names = c("pm10","pm25"),
                       skip_empty_rows = TRUE)

  # --- match P rows to N rows safely ---
  line_types <- tibble(
    line = lines,
    type = case_when(
      grepl("^\\s*P", line)  ~ "P",
      grepl("^\\s*N_", line) ~ "N",
      TRUE                   ~ "OTHER"
    )
  )

  p_idx <- which(line_types$type == "P")
  n_idx <- which(line_types$type == "N")

  # match only the P rows that have N rows
  valid_p_idx <- p_idx[seq_along(n_idx)]

  p_data <- p_data %>% 
    dplyr::slice(match(valid_p_idx, p_idx))

  # ---------- BIT RECONSTRUCTION + CALIBRATION ----------
  temp_factor = 20;      temp_offset = 2.000
  RH_factor   = 20;      RH_offset   = 0
  pressure_factor = 176.21145; pressure_offset = 0.275

  p_data_clean <- p_data %>%
    mutate(
      # LOW 2 BITS PER SENSOR
      lo1 = bitAnd(UeL, 3L),
      lo2 = bitAnd(bitShiftR(UeL, 2L), 3L),
      lo3 = bitAnd(bitShiftR(UeL, 4L), 3L),
      lo4 = bitAnd(bitShiftR(UeL, 6L), 3L),

      # RECONSTRUCT 10-BIT ADC VALUES
      adc1 = Ue1 * 4L + lo1,
      adc2 = Ue2 * 4L + lo2,
      adc3 = Ue3 * 4L + lo3,
      adc4 = Ue4 * 4L + lo4,

      # ADC → VOLTS
      volt1 = adc1 * 10 / 1024,
      volt2 = adc2 * 10 / 1024,
      volt4 = adc4 * 10 / 1024,

      # APPLY CALIBRATION
      temp_c       = (volt1 - temp_offset) * temp_factor,
      rh_percent   = (volt2 - RH_offset) * RH_factor,
      pressure_hpa = (volt4 - pressure_offset) * pressure_factor
    )

  # --- combine calibrated P with PM rows ---
  combined <- bind_cols(p_data_clean, n_data) %>%
    mutate(datetime = make_datetime(year + 2000, month, day, hour, minute),
           date_hour = floor_date(datetime, unit = "hours"),
           date = as.Date(date_hour),
           file = basename(file_path))

  return(combined)
}
```

## Clean multiple days of GRIMM data

```{r}
# factors and offsets pulled from device metadata (NEED TO UPDATE IF DEVICE METADATA IS DIFFERENT)
temp_factor = 20
temp_offset = 2

RH_factor = 20
RH_offset = 0

pressure_factor = 176.21145
pressure_offset = 0.275


## path to GRIMM data folder
folder <- "/Users/lewiswhite/CHAP_columbia/QuantAQ_ghana/data/FEMs/GRIMM/raw/GRIMM_20250811_20251008"

## Create list of the files in the GRIMM folder 
files <- list.files(folder, pattern = "\\.TXT$", full.names = TRUE)

## Apply data cleaning function to all files 
grimm_all <- map_dfr(files, load_grimm_file) 

# summarize grimm data hourly
grimm_hourly <- grimm_all %>%
  group_by(date_hour, date) %>%
  count(!is.na(pm25) | !is.na(temp_c)) %>% ## put in place 45 minute (75%) requirements even though should all be complete
  left_join(grimm_all, by = c("date_hour", "date")) %>%
  filter(n >= 45) %>%
  summarize(grimm_temp = mean(temp_c, na.rm = TRUE),
            grimm_humidity = mean(rh_percent, na.rm = TRUE),
            grimm_pressure = mean(pressure_hpa, na.rm = TRUE),
            grimm_pm25 = mean(pm25, na.rm = TRUE),
            grimm_pm10 = mean(pm10, na.rm = TRUE))

# save summarize output
write_csv(grimm_hourly, here("data", "FEMs", "GRIMM", "clean", "grimm_hourly_20250811-20251008.csv"))


# summarize grimm data daily
grimm_daily <- grimm_hourly  %>%
  group_by(date) %>%
  count(!is.na(grimm_temp) | !is.na(grimm_pm25)) %>% ## put in place 18 hour (75%) requirements even though should all be complete
  left_join(grimm_hourly, by = "date") %>%
  filter(n >= 18) %>%
  summarize(grimm_temp = mean(grimm_temp, na.rm = TRUE),
            grimm_humidity = mean(grimm_humidity, na.rm = TRUE),
            grimm_pressure = mean(grimm_pressure, na.rm = TRUE),
            grimm_pm25 = mean(grimm_pm25, na.rm = TRUE),
            grimm_pm10 = mean(grimm_pm10, na.rm = TRUE))

# save summarized output 
write_csv(grimm_daily, here("data", "FEMs", "GRIMM", "clean", "grimm_daily_20250811-20251008.csv"))

```

