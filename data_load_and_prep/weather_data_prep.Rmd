---
title: "Weather (Temp, Relative Humidity, Wind) Data Prep"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

options(scipen=999)
```

This R Markdown document reads in processed SD card, merges it with cloud data.
 
It starts by cleaning temperature data, then relative humidity, then wind. 

```{r packages, echo=FALSE, message=FALSE, warning=FALSE}
### load packages 

library(here) # file path org
library(lubridate)# working with dates
library(tictoc) # timing
library(DT) # datatables
library(purrr) # applying functions across df
library(tidyverse) # data cleaning and plotting
library(data.table) 
library(sf) # spatial data 
library(viridis) # color pallete 
library(knitr)
library(modelsummary) # table of regressions
library(spdep)
library(gstat)
library(units) 
library(gridExtra)
library(broom)
library(Metrics) 
library(kableExtra) # table creation
library(GGally)
library(stringr)  # for str_extract
library(rlang)    # for sym / !!

# source in function that loads each pollution dataset separately to keep data small and prevent R crashes 
source(here("src", "load_pollution_datasets.R"))


# source function to apply regressions when comparing monitor to fleet average (NOT CURRENTLY IN FLOW, BUT COULD BE ADDED IF WANT TO DO COLOCATION CORRECTION)
source(here("src", "compare_fleet_regression.R")) # INCLUDES apply_regression and run_regression_stats functions. 

# source function that aggregates data by time scale of interest (hourly, daily)
source(here("src", "summarize_pollution_times.R"))
```


# Temperature and RH

Across both MOD and MOD-PM devices, temperature and relative humidity readings are consistent across sources (processed SD card, raw/final downloaded from QuantAQ website, and raw/final cloud exports). MOD devices report these as temp and rh, while MOD-PM devices label them as sample_temp and sample_rh. 

In the cloud data, these values also appear as met_temp and met_rh, but they are equivalent to the external environmental readings provided by temp/sample_temp and rh/sample_rh. All sources report matching values for the same timestamps, indicating that they reflect the same sensor measurements. 

When merging the data below, we harmonize these fields into unified temp and rh variables to ensure consistency across devices and sources.

### Load data


```{r}
## LOAD SD CARD DATA ----

# Load MOD files ----
mod_files1 <- list.files(
  path = "/Users/lewiswhite/CHAP_columbia/QuantAQ_ghana/data/all_measurements/sd/processed_feb_2025/MOD", 
  full.names = TRUE, pattern = "MOD-00.*\\.csv"
)

mod_files2 <- list.files(
  path = "/Users/lewiswhite/CHAP_columbia/QuantAQ_ghana/data/all_measurements/sd/processed_sept_2025/MOD", 
  full.names = TRUE, pattern = "MOD-00.*\\.csv"
)

mod_files <- c(mod_files1, mod_files2)


# load MOD-PM files ----
mod_pm_files1 <- list.files(
  path = "/Users/lewiswhite/CHAP_columbia/QuantAQ_ghana/data/all_measurements/sd/processed_feb_2025/MOD-PM", 
  full.names = TRUE, pattern = "MOD-PM.*\\.csv"
)

mod_pm_files2 <- list.files(
  path = "/Users/lewiswhite/CHAP_columbia/QuantAQ_ghana/data/all_measurements/sd/processed_sept_2025/MOD-PM", 
  full.names = TRUE, pattern = "MOD-PM.*\\.csv"
)

mod_pm_files <- c(mod_pm_files1, mod_pm_files2)




# Works for both MOD and MOD-PM files
read_mod_temp_rh <- function(file) {
  monitor <- str_extract(basename(file), "MOD(?:-PM)?-\\d+")
  df <- read_csv(file, show_col_types = FALSE) %>%
    mutate(timestamp_iso = ymd_hms(timestamp_iso, tz = "UTC"))

  # coalesce ONLY allowed columns (no opc_*)
  tcols <- intersect(c("sample_temp","met_temp"), names(df))
  rcols <- intersect(c("sample_rh","met_rh"),   names(df))

  if (length(tcols) == 0 || length(rcols) == 0) {
    warning("Missing temp/rh in: ", file,
            " (temp cols: ", toString(tcols), 
            "; rh cols: ", toString(rcols), ")")
  }

  tibble(
    timestamp_iso = df$timestamp_iso,
    monitor       = monitor,
    met_temp      = if (length(tcols)) coalesce(!!!df[tcols]) else NA_real_,
    met_rh        = if (length(rcols)) coalesce(!!!df[rcols]) else NA_real_,
    source        = "sd_card"
  )
}



temp_rh_sd_card <- bind_rows(
  map_dfr(mod_files, read_mod_temp_rh),
  map_dfr(mod_pm_files, read_mod_temp_rh)
)

# Save if needed
# write_rds(temp_rh_sd_card, here("data", "weather", "sd", "temp_rh_sd_card_20240820-20250530.rds"))
# temp_rh_sd_card <- read_rds(here("data", "weather", "sd",  "temp_rh_sd_card_20240820-20250530.rds"))



# LOAD THE CLOUD DATA ----

measurements <- c("met_temp", "met_rh")
cloud_file <- "/Users/lewiswhite/CHAP_columbia/QuantAQ_ghana/data/all_measurements/cloud/ghana_AQ_parent_full_20240816_20250901.csv"

raw_data <- map(measurements, ~ load_pollution_datasets(.x, file_path = cloud_file, file_type = "csv"))
names(raw_data) <- measurements
```


### Merge the cloud and SD data
```{r}
# Function to merge sd_card data when cloud data is missing
merge_sd_data <- function(pollutant_data, sd_card_data, pollutant) {
  pollutant_raw <- paste0(pollutant, ".raw")
  pollutant_sd  <- paste0(pollutant, ".sd")

  merged_data <- pollutant_data %>%
    left_join(
      sd_card_data,
      by = c("timestamp" = "timestamp_iso", "monitor"),
      suffix = c(".raw", ".sd")
    ) %>%
    mutate(
      !!pollutant := coalesce(.data[[pollutant_raw]], .data[[pollutant_sd]]),
      source      = coalesce(source.raw, source.sd)
    ) %>%
    select(monitor, timestamp, date, hour, all_of(pollutant), source)

  return(merged_data)
}

# Merge across list of variables
merge_cloud_sd <- function(pollutants, raw_data, sd_card_data) {
  setNames(
    lapply(pollutants, function(p) {
      cloud_full <- raw_data[[p]]$raw_cloud
      merge_sd_data(cloud_full, sd_card_data, p)
    }),
    pollutants
  )
}

# If SD card data is missing or zero rows → create an empty-but-valid SD tibble
if (is.null(temp_rh_sd_card) || nrow(temp_rh_sd_card) == 0) {
  message("⚠ No SD card WEATHER data found — proceeding with cloud-only workflow")

  temp_rh_sd_card <- tibble::tibble(
    timestamp_iso = as_datetime(character()),
    monitor       = character(),
    met_temp      = numeric(),
    met_rh        = numeric(),
    source        = character()
  )
}

# Complete the merge 
merged_weather <- merge_cloud_sd(measurements, raw_data, temp_rh_sd_card)

# Access merged layers
met_temp_merged <- merged_weather$met_temp
met_rh_merged   <- merged_weather$met_rh




## save outputs
# write_csv(met_temp_merged, here("data", "weather", "merged", "met_temp_merged_20240816-20250901.csv"))
# write_csv(met_rh_merged, here("data", "weather", "merged",  "met_rh_merged_20240816-20250901.csv"))
# write_rds(met_temp_merged, here("data", "weather", "merged", "met_temp_merged_20240816-20250901.rds"))
# write_rds(met_rh_merged, here("data", "weather", "merged", "met_rh_merged_20240816-20250901.rds"))

```


# summarize temp and rh hourly and daily

```{r}
## summarize the temp and rh using the summarize_pollution_times function 

# temp
met_temp_summary <- summarize_pollution_times(met_temp_merged, "met_temp")

temp_hourly <- met_temp_summary$hourly
temp_daily <- met_temp_summary$daily

# rh
met_rh_summary <- summarize_pollution_times(met_rh_merged, "met_rh")

rh_hourly <- met_rh_summary$hourly
rh_daily <- met_rh_summary$daily


# save the summarized outputs 
#temp
write_csv(temp_hourly, here("data", "weather", "summarized", "temp_hourly_20240816-20250901.csv"))
write_csv(temp_daily, here("data", "weather", "summarized", "temp_daily_20240816-20250901.csv"))

# rh
write_csv(rh_hourly, here("data", "weather", "summarized", "rh_hourly_20240816-20250901.csv"))
write_csv(rh_daily, here("data", "weather", "summarized", "rh_daily_20240816-20250901.csv"))

```


## Wind speed and wind direction 

```{r}
#SD CARD ----

# List all MOD files with full path
mod_files1 <- list.files(
  path = "/Users/lewiswhite/CHAP_columbia/QuantAQ_ghana/data/all_measurements/sd/processed_feb_2025/MOD", 
  full.names = TRUE, 
  recursive = FALSE, 
  pattern = "MOD-00.*\\.csv"
)

mod_files2 <- list.files(
  path = "/Users/lewiswhite/CHAP_columbia/QuantAQ_ghana/data/all_measurements/sd/processed_sept_2025/MOD", 
  full.names = TRUE, 
  recursive = FALSE, 
  pattern = "MOD-00.*\\.csv"
)

mod_files <- c(mod_files1, mod_files2)


# Function to read, select columns, and add monitor name for MOD files
read_mod_ws_wd <- function(file) {
  monitor_name <- stringr::str_extract(basename(file), "MOD-\\d+")
  
  readr::read_csv(file, show_col_types = FALSE) %>%
    dplyr::mutate(timestamp_iso = lubridate::ymd_hms(timestamp_iso, tz = "UTC"),
                  monitor = monitor_name) %>%
    dplyr::select(timestamp_iso, ws, wd, monitor) %>%
    dplyr::distinct(monitor, timestamp_iso, .keep_all = TRUE)
}

ws_wd_sd_card <- purrr::map_dfr(mod_files, read_mod_ws_wd) %>%
  dplyr::filter(timestamp_iso >= lubridate::ymd_hms("2024-08-15 00:00:00", tz = "UTC")) %>%
  dplyr::mutate(source = "sd_card")



# write_rds(ws_wd_sd_card, here("data", "weather", "sd", "ws_wd_sd_card_20240820-20250530.rds"))
# ws_wd_sd_card <- read_rds(here("data", "weather", "sd", "ws_wd_sd_card_20240820-20250530.rds"))






# LOAD CLOUD DATA

measurements <- c("ws", "wd")
cloud_file <- "/Users/lewiswhite/CHAP_columbia/QuantAQ_ghana/data/all_measurements/cloud/ghana_AQ_parent_full_20240816_20250901.csv"

raw_data <- map(measurements, ~ load_pollution_datasets(.x, file_path = cloud_file, file_type = "csv"))

names(raw_data) <- measurements
```

## Merge

```{r}
## MERGE THE SD DATA WITH THE SERVER DATA ---- 

if (nrow(ws_wd_sd_card) == 0 || is.null(ws_wd_sd_card)) {
  ws_wd_sd_card <- tibble(
    timestamp_iso = as_datetime(character()),
    ws = numeric(),
    wd = numeric(),
    monitor = character(),
    source = character()
  )
}


# NOTE: merge_cloud_sd() is defined earlier in the temp/RH section.
merged_wind <- merge_cloud_sd(measurements, raw_data, ws_wd_sd_card)

# access (note: no $merged_full layer anymore)
ws_merged <- merged_wind$ws
wd_merged   <- merged_wind$wd


# save output
write_rds(ws_merged, here("data", "weather", "merged", "ws_merged_20240816-20250901.rds"))
write_rds(wd_merged, here("data", "weather", "merged", "wd_merged_20240816-20250901.rds"))


```


## Join the weather variables 

```{r}
met_temp_merged_unique <- met_temp_merged %>%
  select(monitor, timestamp, met_temp) %>%
  filter(!is.na(met_temp)) %>%
  distinct(timestamp, monitor, .keep_all = TRUE)

met_rh_merged_unique <- met_rh_merged %>%
  select(monitor, timestamp, met_rh) %>%
  filter(!is.na(met_rh)) %>%
  distinct(timestamp, monitor, .keep_all = TRUE)

ws_merged_merged_unique <- ws_merged %>%
  select(monitor, timestamp, ws) %>%
  filter(!is.na(ws)) %>%
  distinct(timestamp, monitor, .keep_all = TRUE)

wd_merged_merged_unique <- wd_merged %>%
  select(monitor, timestamp, wd) %>%
  filter(!is.na(wd)) %>%
  distinct(timestamp, monitor, .keep_all = TRUE)



# create full temp rh data 
temp_rh_full <- full_join(met_temp_merged_unique, met_rh_merged_unique, by = c("timestamp", "monitor")) %>% 
  mutate(date = date(timestamp),
         hour = hour(timestamp)) %>%
  select(monitor, timestamp, date, hour, met_temp, met_rh)
  

# save output 
write_rds(temp_rh_full, here("data", "weather", "merged", "temp_rh_full_20240816-20250901.rds"))



# create full wind data 
wind_full <- full_join(ws_merged_merged_unique, wd_merged_merged_unique, by = c("timestamp", "monitor")) %>%
  filter(!is.na(ws)) %>% filter(wd >= 0, wd <= 360) %>% # wind direction doesn't matter if ws isn't there
  mutate(date = date(timestamp),
         hour = hour(timestamp)) %>%
  select(monitor, timestamp, date, hour, ws, wd)

# save output 
write_rds(wind_full, here("data", "weather", "merged", "wind_full_20240816-20250901.rds"))



# create weather full 
weather_full <- full_join(met_temp_merged_unique, met_rh_merged_unique, by = c("timestamp", "monitor")) %>%
  full_join(ws_merged_merged_unique, by = c("timestamp", "monitor")) %>%
  full_join(wd_merged_merged_unique, by = c("timestamp", "monitor"))

weather_full <- weather_full %>%
  mutate(date = date(timestamp),
         hour = hour(timestamp))

# save output 
write_rds(weather_full, here("data", "weather", "all_weather", "all_weather_vars_20240816-20250901.rds"))
```


